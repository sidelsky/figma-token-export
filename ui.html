<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Design Token Export</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: #ffffff;
      color: #333;
      line-height: 1.5;
    }

    .container {
      max-width: 100%;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      margin: 0 0 16px 0;
      color: #1a1a1a;
    }

    .description {
      font-size: 14px;
      color: #666;
      margin-bottom: 24px;
      line-height: 1.4;
    }

    .export-section {
      border: 1px solid #e1e5e9;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .export-title {
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #1a1a1a;
    }

    .export-info {
      font-size: 12px;
      color: #666;
      margin-bottom: 16px;
    }

    .button {
      background: #18a0fb;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      width: 100%;
      transition: background-color 0.2s ease;
    }

    .button:hover {
      background: #1592e6;
    }

    .button:disabled {
      background: #b3d9ff;
      cursor: not-allowed;
    }

    .button.secondary {
      background: #ffffff;
      color: #666;
      border: 1px solid #e1e5e9;
    }

    .button.secondary:hover {
      background: #f8f9fa;
    }

    .status {
      margin-top: 16px;
      padding: 12px;
      border-radius: 6px;
      font-size: 12px;
      display: none;
    }

    .status.success {
      background: #e8f5e8;
      color: #2d6a2d;
      border: 1px solid #c3e6c3;
    }

    .status.error {
      background: #ffeaea;
      color: #c53030;
      border: 1px solid #feb2b2;
    }

    .status.loading {
      background: #e6f3ff;
      color: #1a73e8;
      border: 1px solid #b3d9ff;
    }

    .preview-section {
      margin-top: 16px;
      display: none;
    }

    .preview-title {
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      color: #1a1a1a;
    }

    .preview-content {
      background: #f8f9fa;
      border: 1px solid #e1e5e9;
      border-radius: 6px;
      padding: 12px;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 11px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .actions {
      display: flex;
      gap: 8px;
      margin-top: 16px;
    }

    .actions .button {
      flex: 1;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Design Token Export</h1>
    <p class="description">
      Export your Figma variables and design tokens into a JSON format that developers can easily use in their projects.
    </p>

    <div class="export-section">
      <div class="export-title">Export Options</div>
      <div class="export-info">
        This will export all local variable collections including colors, typography, spacing, and other design tokens.
      </div>

      <div class="format-options" style="margin-bottom: 16px;">
        <div style="font-size: 12px; font-weight: 500; margin-bottom: 8px; color: #1a1a1a;">Export Format:</div>
        <select id="exportFormat"
          style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px; background: #ffffff; color: #333;">
          <option value="json">JSON (for JavaScript/build tools)</option>
          <option value="css">CSS Custom Properties</option>
          <option value="developer">Developer JSON (W3C Format)</option>
        </select>
      </div>

      <button id="exportBtn" class="button">
        Export Design Tokens
      </button>

      <div id="status" class="status"></div>
    </div>

    <div id="previewSection" class="preview-section">
      <div id="previewTitle" class="preview-title">Export Preview</div>
      <div id="previewContent" class="preview-content"></div>

      <div class="actions">
        <button id="downloadBtn" class="button">Download</button>
        <button id="copyBtn" class="button secondary">Copy to Clipboard</button>
      </div>
    </div>

    <!-- GitHub Integration Section -->
    <div id="githubSection" class="export-section" style="display: none;">
      <div class="export-title"
        style="display: flex; justify-content: space-between; align-items: center; cursor: pointer;" id="githubToggle">
        <span>ðŸ”— Push to GitHub</span>
        <span id="githubToggleIcon">â–¼</span>
      </div>

      <div id="githubSettings" style="margin-top: 16px;">
        <div class="export-info">
          Configure your GitHub repository to automatically push design tokens.
        </div>

        <div style="margin-bottom: 12px;">
          <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #1a1a1a;">
            Repository URL or owner/repo
          </label>
          <input id="githubRepo" type="text" placeholder="username/repo or https://github.com/username/repo"
            style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px;" />
          <div style="font-size: 11px; color: #666; margin-top: 4px;">
            Example: myorg/design-tokens
          </div>
        </div>

        <div style="display: flex; gap: 8px; margin-bottom: 12px;">
          <div style="flex: 1;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #1a1a1a;">
              Branch
            </label>
            <input id="githubBranch" type="text" value="main" placeholder="main"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px;" />
          </div>
          <div style="flex: 2;">
            <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #1a1a1a;">
              File Path
            </label>
            <input id="githubFilePath" type="text" value="tokens/design-tokens.json"
              placeholder="tokens/design-tokens.json"
              style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px;" />
          </div>
        </div>

        <div style="margin-bottom: 12px;">
          <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #1a1a1a;">
            GitHub Personal Access Token
          </label>
          <input id="githubToken" type="password" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
            style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px;" />
          <div style="font-size: 11px; color: #666; margin-top: 4px;">
            <a href="https://github.com/settings/tokens/new?scopes=repo&description=Figma%20Token%20Export"
              target="_blank" style="color: #18a0fb; text-decoration: none;">
              Create a token
            </a> with 'repo' scope
          </div>
        </div>

        <div style="margin-bottom: 12px;">
          <label style="display: block; font-size: 12px; font-weight: 500; margin-bottom: 4px; color: #1a1a1a;">
            Commit Message
          </label>
          <input id="githubCommitMessage" type="text" value="Update design tokens from Figma"
            placeholder="Update design tokens"
            style="width: 100%; padding: 8px 12px; border: 1px solid #e1e5e9; border-radius: 6px; font-size: 14px;" />
        </div>

        <div style="display: flex; gap: 8px;">
          <button id="saveGithubSettings" class="button secondary" style="flex: 1;">
            ðŸ’¾ Save Settings
          </button>
          <button id="pushToGithub" class="button" style="flex: 2;" disabled>
            ðŸš€ Push to GitHub
          </button>
        </div>

        <div id="githubStatus" class="status" style="margin-top: 12px;"></div>
      </div>
    </div>

    <div class="actions">
      <button id="closeBtn" class="button secondary">Close</button>
    </div>
  </div>

  <script>
"use strict";
(() => {
  // src/github.ts
  async function pushToGitHub(options) {
    const { config, content, commitMessage } = options;
    const { token, owner, repo, branch, filePath } = config;
    try {
      const sha = await getFileSHA(config);
      const response = await fetch(
        `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`,
        {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
            Accept: "application/vnd.github.v3+json"
          },
          body: JSON.stringify({
            message: commitMessage,
            content: btoa(unescape(encodeURIComponent(content))),
            // Base64 encode
            branch,
            ...sha ? { sha } : {}
            // Include SHA if file exists
          })
        }
      );
      if (!response.ok) {
        const error = await response.json();
        throw new Error(
          error.message || `GitHub API error: ${response.statusText}`
        );
      }
      const result = await response.json();
      return {
        success: true,
        message: "Successfully pushed to GitHub!",
        commitUrl: result.commit?.html_url
      };
    } catch (error) {
      console.error("GitHub push error:", error);
      return {
        success: false,
        message: error instanceof Error ? error.message : "Failed to push to GitHub. Please check your settings."
      };
    }
  }
  async function getFileSHA(config) {
    const { token, owner, repo, branch, filePath } = config;
    try {
      const response = await fetch(
        `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}?ref=${branch}`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: "application/vnd.github.v3+json"
          }
        }
      );
      if (response.status === 404) {
        return null;
      }
      if (!response.ok) {
        throw new Error(`Failed to get file info: ${response.statusText}`);
      }
      const data = await response.json();
      return data.sha;
    } catch (error) {
      console.log("File does not exist yet, will create new file");
      return null;
    }
  }
  function parseRepoUrl(url) {
    const cleaned = url.trim().replace(/\/$/, "").replace(/\.git$/, "");
    const httpsMatch = cleaned.match(/github\.com\/([^/]+)\/([^/]+)/);
    if (httpsMatch && httpsMatch[1] && httpsMatch[2]) {
      return { owner: httpsMatch[1], repo: httpsMatch[2] };
    }
    const sshMatch = cleaned.match(/git@github\.com:([^/]+)\/(.+)/);
    if (sshMatch && sshMatch[1] && sshMatch[2]) {
      return { owner: sshMatch[1], repo: sshMatch[2] };
    }
    const shortMatch = cleaned.match(/^([^/]+)\/([^/]+)$/);
    if (shortMatch && shortMatch[1] && shortMatch[2]) {
      return { owner: shortMatch[1], repo: shortMatch[2] };
    }
    return null;
  }

  // src/ui.ts
  console.log("UI script starting to execute...");
  var exportedData = null;
  var exportBtn;
  var downloadBtn;
  var copyBtn;
  var closeBtn;
  var status;
  var previewSection;
  var previewContent;
  var previewTitle;
  var githubSection;
  var githubToggle;
  var githubSettings;
  var githubToggleIcon;
  var githubRepoInput;
  var githubBranchInput;
  var githubFilePathInput;
  var githubTokenInput;
  var githubCommitMessageInput;
  var saveGithubSettingsBtn;
  var pushToGithubBtn;
  var githubStatus;
  var githubSettingsCollapsed = false;
  function initializePlugin() {
    console.log("initializePlugin called");
    exportBtn = getElementById("exportBtn");
    downloadBtn = getElementById("downloadBtn");
    copyBtn = getElementById("copyBtn");
    closeBtn = getElementById("closeBtn");
    status = getElementById("status");
    previewSection = getElementById("previewSection");
    previewContent = getElementById("previewContent");
    previewTitle = getElementById("previewTitle");
    githubSection = getElementById("githubSection");
    githubToggle = getElementById("githubToggle");
    githubSettings = getElementById("githubSettings");
    githubToggleIcon = getElementById("githubToggleIcon");
    githubRepoInput = getElementById("githubRepo");
    githubBranchInput = getElementById("githubBranch");
    githubFilePathInput = getElementById("githubFilePath");
    githubTokenInput = getElementById("githubToken");
    githubCommitMessageInput = getElementById("githubCommitMessage");
    saveGithubSettingsBtn = getElementById("saveGithubSettings");
    pushToGithubBtn = getElementById("pushToGithub");
    githubStatus = getElementById("githubStatus");
    console.log("All DOM elements found, setting up event listeners...");
    exportBtn.addEventListener("click", handleExport);
    downloadBtn.addEventListener("click", handleDownload);
    copyBtn.addEventListener("click", handleCopy);
    closeBtn.addEventListener("click", handleClose);
    githubToggle.addEventListener("click", toggleGithubSettings);
    saveGithubSettingsBtn.addEventListener("click", saveGithubSettings);
    pushToGithubBtn.addEventListener("click", handlePushToGithub);
    loadGithubSettings();
    updateDownloadButtonText();
    const formatSelect = getElementById("exportFormat");
    formatSelect.addEventListener("change", () => {
      console.log("Export format changed to:", formatSelect.value);
      updateDownloadButtonText();
      if (exportedData) {
        updatePreviewContent();
      }
    });
    window.onmessage = (event) => {
      console.log("Received message:", event.data);
      if (!event.data.pluginMessage) return;
      const { type, data, message } = event.data.pluginMessage;
      switch (type) {
        case "tokens-extracted":
          if (data) {
            handleTokensExtractedWithGithub(data);
          }
          break;
        case "error":
          handleError(message || "Unknown error occurred");
          break;
        default:
          console.warn("Unknown message type:", type);
      }
    };
    console.log("\u2705 Plugin UI initialized successfully!");
  }
  function getElementById(id) {
    const element = document.getElementById(id);
    if (!element) {
      throw new Error(`Element with id "${id}" not found`);
    }
    return element;
  }
  function handleTokensExtracted(data) {
    exportBtn.disabled = false;
    exportBtn.textContent = "Export Design Tokens";
    updateDownloadButtonText();
    const collectionCount = Object.keys(data.collections).length;
    showStatus(
      "success",
      `Successfully extracted ${collectionCount} collection(s)!`
    );
    showPreview(data);
  }
  function handleError(message) {
    exportBtn.disabled = false;
    exportBtn.textContent = "Export Design Tokens";
    showStatus("error", `Error: ${message}`);
  }
  function handleExport() {
    console.log("Starting export process...");
    showStatus("loading", "Extracting design tokens...");
    exportBtn.disabled = true;
    exportBtn.textContent = "Exporting...";
    const message = { type: "export-tokens" };
    parent.postMessage({ pluginMessage: message }, "*");
  }
  function getSelectedFormat() {
    const formatSelect = document.getElementById(
      "exportFormat"
    );
    if (formatSelect) {
      return formatSelect.value;
    }
    return "json";
  }
  function convertToCSS(data) {
    let css = "/* Design Tokens exported from Figma */\n";
    css += `/* Exported at: ${data.metadata.exportedAt} */
`;
    css += `/* File: ${data.metadata.figmaFileKey || "Unknown"} */
`;
    css += `/* Collections: ${Object.keys(data.collections).join(", ")} */

`;
    const modeNames = [
      ...new Set(
        Object.values(data.collections).flatMap(
          (collection) => Object.values(collection.variables).flatMap(
            (variable) => Object.keys(variable.values)
          )
        )
      )
    ];
    css += "/* Usage Examples:\n";
    css += " * .button { background: var(--colors-primary); }\n";
    css += " * .text { font-size: var(--typography-body-size); }\n";
    if (modeNames.length > 1) {
      const darkMode = modeNames.find((mode) => mode !== "Default" && mode !== "Light") || modeNames[1];
      css += ` * Toggle themes: document.body.setAttribute("data-theme", "${darkMode}"); */

`;
    } else {
      css += " */\n\n";
    }
    const modeGroups = {};
    Object.entries(data.collections).forEach(([collectionName, collection]) => {
      Object.entries(collection.variables).forEach(([varName, variable]) => {
        Object.entries(variable.values).forEach(([modeName, value]) => {
          if (!modeGroups[modeName]) {
            modeGroups[modeName] = [];
          }
          const cssVarName = `--${collectionName.toLowerCase()}-${varName.toLowerCase()}`.replace(
            /[^a-z0-9-]/g,
            "-"
          );
          const cssValue = formatValueForCSS(value, variable.type);
          const comment = variable.description ? ` /* ${variable.description} */` : "";
          modeGroups[modeName].push(`  ${cssVarName}: ${cssValue};${comment}`);
        });
        Object.entries(variable.aliases).forEach(([modeName, alias]) => {
          if (!modeGroups[modeName]) {
            modeGroups[modeName] = [];
          }
          const cssVarName = `--${collectionName.toLowerCase()}-${varName.toLowerCase()}`.replace(
            /[^a-z0-9-]/g,
            "-"
          );
          const aliasName = alias.name.toLowerCase().replace(/[^a-z0-9-]/g, "-");
          const comment = ` /* alias to ${alias.name} */`;
          modeGroups[modeName].push(
            `  ${cssVarName}: var(--${aliasName});${comment}`
          );
        });
      });
    });
    Object.entries(modeGroups).forEach(([modeName, variables]) => {
      if (modeName === "Default" || modeName === "Light" || Object.keys(modeGroups).length === 1) {
        css += ":root {\n";
        css += `  /* Mode: ${modeName} */
`;
      } else {
        css += `[data-theme="${modeName}"] {
`;
        css += `  /* Mode: ${modeName} */
`;
      }
      css += variables.join("\n") + "\n";
      css += "}\n\n";
    });
    return css;
  }
  function formatValueForCSS(value, type) {
    switch (type) {
      case "COLOR":
        return String(value);
      case "FLOAT":
        if (typeof value === "number" && value > 0 && value < 1e3 && Number.isInteger(value)) {
          return `${value}px`;
        }
        return String(value);
      case "STRING":
        return `"${value}"`;
      case "BOOLEAN":
        return value ? "1" : "0";
      default:
        return String(value);
    }
  }
  function convertToDeveloperFormat(data) {
    const result = {};
    Object.entries(data.collections).forEach(([collectionName, collection]) => {
      const category = categorizeCollection(collectionName);
      if (!result[category]) {
        result[category] = {};
      }
      Object.entries(collection.variables).forEach(([varName, variable]) => {
        const primaryMode = collection.modes.find(
          (m) => m.name === "Default" || m.name === "Light"
        ) || collection.modes[0];
        if (!primaryMode) return;
        const primaryModeName = primaryMode.name;
        let value = variable.values[primaryModeName];
        if (value === void 0 && variable.aliases[primaryModeName]) {
          value = `{${variable.aliases[primaryModeName].name}}`;
        }
        if (value === void 0) return;
        const token = {
          $type: mapFigmaTypeToW3C(variable.type),
          $value: value
        };
        if (variable.description) {
          token.$description = variable.description;
        }
        const tokenPath = parseTokenName(varName);
        setNestedValue(result[category], tokenPath, token);
      });
    });
    return result;
  }
  function categorizeCollection(collectionName) {
    const name = collectionName.toLowerCase();
    if (name.includes("color") || name.includes("colour")) return "colors";
    if (name.includes("spacing") || name.includes("space")) return "spacing";
    if (name.includes("typography") || name.includes("font") || name.includes("text"))
      return "typography";
    if (name.includes("radius") || name.includes("border")) return "borderRadius";
    if (name.includes("shadow")) return "shadows";
    if (name.includes("size") || name.includes("sizing")) return "sizing";
    if (name.includes("opacity") || name.includes("alpha")) return "opacity";
    if (name.includes("duration") || name.includes("timing")) return "animation";
    return collectionName.toLowerCase().replace(/\s+/g, "-");
  }
  function mapFigmaTypeToW3C(figmaType) {
    switch (figmaType) {
      case "COLOR":
        return "color";
      case "FLOAT":
        return "number";
      case "STRING":
        return "string";
      case "BOOLEAN":
        return "boolean";
      default:
        return figmaType.toLowerCase();
    }
  }
  function parseTokenName(name) {
    let parts = [];
    if (name.includes("/")) {
      parts = name.split("/");
    } else if (name.includes("-")) {
      parts = name.split("-");
    } else if (name.includes("_")) {
      parts = name.split("_");
    } else {
      parts = name.split(/(?=[A-Z])/).map((p) => p.toLowerCase());
      if (parts.length === 1) {
        parts = [name];
      }
    }
    return parts.map((p) => p.trim().toLowerCase()).filter((p) => p.length > 0);
  }
  function setNestedValue(obj, path, value) {
    if (path.length === 0) return;
    const key = path[0];
    if (!key) return;
    if (path.length === 1) {
      obj[key] = value;
      return;
    }
    const [first, ...rest] = path;
    if (!first) return;
    if (!obj[first]) {
      obj[first] = {};
    }
    setNestedValue(obj[first], rest, value);
  }
  function handleDownload() {
    if (!exportedData) return;
    const format = getSelectedFormat();
    const dateStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    try {
      if (format === "json") {
        const content = JSON.stringify(exportedData, null, 2);
        downloadFile(
          content,
          "application/json",
          `design-tokens-${dateStr}.json`
        );
        showStatus("success", "JSON file downloaded successfully!");
      } else if (format === "css") {
        const content = convertToCSS(exportedData);
        downloadFile(content, "text/css", `design-tokens-${dateStr}.css`);
        showStatus("success", "CSS file downloaded successfully!");
      } else if (format === "developer") {
        const content = JSON.stringify(
          convertToDeveloperFormat(exportedData),
          null,
          2
        );
        downloadFile(
          content,
          "application/json",
          `design-tokens-developer-${dateStr}.json`
        );
        showStatus("success", "Developer JSON file downloaded successfully!");
      }
    } catch (error) {
      console.error("Download error:", error);
      showStatus("error", "Failed to download file");
    }
  }
  function downloadFile(content, mimeType, filename) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
  function updateDownloadButtonText() {
    if (!downloadBtn || !copyBtn) return;
    const format = getSelectedFormat();
    switch (format) {
      case "json":
        downloadBtn.textContent = "Download JSON";
        copyBtn.textContent = "Copy JSON";
        break;
      case "css":
        downloadBtn.textContent = "Download CSS";
        copyBtn.textContent = "Copy CSS";
        break;
      case "developer":
        downloadBtn.textContent = "Download Developer JSON";
        copyBtn.textContent = "Copy Developer JSON";
        break;
      default:
        downloadBtn.textContent = "Download";
        copyBtn.textContent = "Copy to Clipboard";
    }
  }
  async function handleCopy() {
    if (!exportedData) return;
    try {
      const format = getSelectedFormat();
      let content;
      let message;
      if (format === "json") {
        content = JSON.stringify(exportedData, null, 2);
        message = "JSON copied to clipboard!";
      } else if (format === "css") {
        content = convertToCSS(exportedData);
        message = "CSS copied to clipboard!";
      } else if (format === "developer") {
        content = JSON.stringify(convertToDeveloperFormat(exportedData), null, 2);
        message = "Developer JSON copied to clipboard!";
      } else {
        throw new Error("Unknown format");
      }
      await navigator.clipboard.writeText(content);
      showStatus("success", message);
    } catch (error) {
      console.error("Copy error:", error);
      showStatus("error", "Failed to copy to clipboard");
    }
  }
  function handleClose() {
    console.log("Closing plugin...");
    const message = { type: "close-plugin" };
    parent.postMessage({ pluginMessage: message }, "*");
  }
  function showStatus(type, message) {
    if (!status) return;
    status.className = `status ${type}`;
    status.textContent = message;
    status.style.display = "block";
    if (type === "success") {
      setTimeout(() => {
        status.style.display = "none";
      }, 3e3);
    }
  }
  function showPreview(data) {
    exportedData = data;
    updatePreviewContent();
    if (previewSection) {
      previewSection.style.display = "block";
    }
  }
  function updatePreviewContent() {
    if (!exportedData || !previewContent) return;
    const format = getSelectedFormat();
    if (format === "css") {
      const cssContent = convertToCSS(exportedData);
      previewContent.textContent = cssContent;
      if (previewTitle) previewTitle.textContent = "CSS Preview";
    } else if (format === "developer") {
      const developerContent = convertToDeveloperFormat(exportedData);
      previewContent.textContent = JSON.stringify(developerContent, null, 2);
      if (previewTitle)
        previewTitle.textContent = "Developer JSON Preview (W3C Format)";
    } else {
      const preview = createJSONPreview(exportedData);
      previewContent.textContent = JSON.stringify(preview, null, 2);
      if (previewTitle) previewTitle.textContent = "JSON Preview";
    }
  }
  function createJSONPreview(data) {
    return {
      metadata: data.metadata,
      collections: Object.fromEntries(
        Object.entries(data.collections).map(([collectionName, collection]) => {
          const variableNames = Object.keys(collection.variables);
          const previewVariables = Object.fromEntries(
            variableNames.slice(0, 3).map((name) => [name, collection.variables[name]])
          );
          if (variableNames.length > 3) {
            previewVariables["..."] = `and ${variableNames.length - 3} more variables`;
          }
          return [
            collectionName,
            {
              name: collection.name,
              modes: collection.modes,
              variableCount: variableNames.length,
              variables: previewVariables
            }
          ];
        })
      )
    };
  }
  function toggleGithubSettings() {
    githubSettingsCollapsed = !githubSettingsCollapsed;
    if (githubSettingsCollapsed) {
      githubSettings.style.display = "none";
      githubToggleIcon.textContent = "\u25B6";
    } else {
      githubSettings.style.display = "block";
      githubToggleIcon.textContent = "\u25BC";
    }
  }
  async function loadGithubSettings() {
    const savedSettings = localStorage.getItem("githubSettings");
    if (savedSettings) {
      try {
        const settings = JSON.parse(savedSettings);
        githubRepoInput.value = settings.repoUrl || "";
        githubBranchInput.value = settings.branch || "main";
        githubFilePathInput.value = settings.filePath || "tokens/design-tokens.json";
        if (settings.token) {
          githubTokenInput.value = settings.token;
        }
      } catch (error) {
        console.error("Failed to load GitHub settings:", error);
      }
    }
  }
  async function saveGithubSettings() {
    const repoUrl = githubRepoInput.value.trim();
    const branch = githubBranchInput.value.trim();
    const filePath = githubFilePathInput.value.trim();
    const token = githubTokenInput.value.trim();
    if (!repoUrl || !branch || !filePath) {
      showGithubStatus("error", "Please fill in all required fields");
      return;
    }
    const parsed = parseRepoUrl(repoUrl);
    if (!parsed) {
      showGithubStatus("error", "Invalid repository URL format");
      return;
    }
    const settings = {
      repoUrl,
      branch,
      filePath
    };
    if (token) {
      settings.token = token;
    }
    try {
      localStorage.setItem("githubSettings", JSON.stringify(settings));
      showGithubStatus("success", "Settings saved successfully!");
      if (exportedData) {
        pushToGithubBtn.disabled = false;
      }
    } catch (error) {
      console.error("Failed to save settings:", error);
      showGithubStatus("error", "Failed to save settings");
    }
  }
  async function handlePushToGithub() {
    if (!exportedData) {
      showGithubStatus("error", "Please export tokens first");
      return;
    }
    const repoUrl = githubRepoInput.value.trim();
    const branch = githubBranchInput.value.trim();
    const filePath = githubFilePathInput.value.trim();
    const token = githubTokenInput.value.trim();
    const commitMessage = githubCommitMessageInput.value.trim();
    if (!repoUrl || !branch || !filePath || !token) {
      showGithubStatus("error", "Please fill in all fields including token");
      return;
    }
    const parsed = parseRepoUrl(repoUrl);
    if (!parsed) {
      showGithubStatus("error", "Invalid repository URL format");
      return;
    }
    const format = getSelectedFormat();
    let content;
    try {
      if (format === "json") {
        content = JSON.stringify(exportedData, null, 2);
      } else if (format === "css") {
        content = convertToCSS(exportedData);
      } else if (format === "developer") {
        content = JSON.stringify(convertToDeveloperFormat(exportedData), null, 2);
      } else {
        throw new Error("Unknown format");
      }
    } catch (error) {
      console.error("Failed to generate content:", error);
      showGithubStatus("error", "Failed to generate export content");
      return;
    }
    showGithubStatus("loading", "Pushing to GitHub...");
    pushToGithubBtn.disabled = true;
    pushToGithubBtn.textContent = "Pushing...";
    try {
      const result = await pushToGitHub({
        config: {
          token,
          owner: parsed.owner,
          repo: parsed.repo,
          branch,
          filePath
        },
        content,
        commitMessage: commitMessage || "Update design tokens from Figma"
      });
      if (result.success) {
        showGithubStatus("success", result.message);
        if (result.commitUrl) {
          githubStatus.innerHTML = `
          \u2705 ${result.message} 
          <a href="${result.commitUrl}" target="_blank" style="color: #18a0fb; text-decoration: none;">
            View commit \u2192
          </a>
        `;
        }
      } else {
        showGithubStatus("error", result.message);
      }
    } catch (error) {
      console.error("Push error:", error);
      showGithubStatus(
        "error",
        error instanceof Error ? error.message : "Failed to push to GitHub"
      );
    } finally {
      pushToGithubBtn.disabled = false;
      pushToGithubBtn.textContent = "\u{1F680} Push to GitHub";
    }
  }
  function showGithubStatus(type, message) {
    if (!githubStatus) return;
    githubStatus.className = `status ${type}`;
    githubStatus.textContent = message;
    githubStatus.style.display = "block";
    if (type === "success") {
      setTimeout(() => {
        githubStatus.style.display = "none";
      }, 5e3);
    }
  }
  function handleTokensExtractedWithGithub(data) {
    handleTokensExtracted(data);
    githubSection.style.display = "block";
    const savedSettings = localStorage.getItem("githubSettings");
    if (savedSettings) {
      try {
        const settings = JSON.parse(savedSettings);
        githubRepoInput.value = settings.repoUrl || "";
        githubBranchInput.value = settings.branch || "main";
        githubFilePathInput.value = settings.filePath || "tokens/design-tokens.json";
        if (settings.token) {
          githubTokenInput.value = settings.token;
        }
        if (settings.repoUrl && settings.branch && settings.filePath) {
          pushToGithubBtn.disabled = false;
        }
      } catch (error) {
        console.error("Failed to parse saved settings:", error);
      }
    }
  }
  console.log("Document ready state:", document.readyState);
  if (document.readyState === "loading") {
    console.log("DOM still loading, waiting for DOMContentLoaded...");
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOM loaded via event, initializing plugin UI...");
      initializePlugin();
    });
  } else {
    console.log("DOM already loaded, initializing immediately...");
    initializePlugin();
  }
})();

  </script>
</body>

</html>